<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Puzzle - Без подсказок</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: white;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; }
        #level-text { font-size: 1.2rem; color: #00ff88; font-weight: bold; margin-top: 5px; }
        #shape-name { font-size: 0.9rem; color: #aaa; margin-top: 5px; font-style: italic; }
        
        #win-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff88;
            font-size: 4rem;
            font-weight: 800;
            text-shadow: 0 0 20px #00ff88;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-align: center;
            z-index: 10;
        }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="ui">
        <h1>SHADOW CAST</h1>
        <div id="level-text">УРОВЕНЬ: 1</div>
        <div id="shape-name">Куб</div>
    </div>
    
    <div id="win-msg">ОТЛИЧНО!</div>

    <script type="module">
        import * as THREE from 'three';

        // --- Настройки ---
        let level = 1;
        const WIN_TOLERANCE = 0.5; // Погрешность (0.5 = легко, 0.2 = сложно)

        let isDragging = false;
        let isTransitioning = false;
        let previousMouse = { x: 0, y: 0 };

        // --- Сцена ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 13);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Свет ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xffffff, 150);
        spotLight.position.set(5, 10, 10);
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 2048;
        spotLight.shadow.mapSize.height = 2048;
        scene.add(spotLight);

        // --- Объекты ---
        
        // Стена
        const wallGeo = new THREE.PlaneGeometry(60, 60);
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 });
        const wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.z = -8;
        wall.receiveShadow = true;
        scene.add(wall);

        // Начальная геометрия
        let geometry = new THREE.BoxGeometry(1,1,1);

        // Цель (Призрак)
        const targetMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, wireframe: true, transparent: true, opacity: 0.3 });
        const targetMesh = new THREE.Mesh(geometry, targetMat);
        scene.add(targetMesh);

        // Игрок (Твердый объект)
        const playerMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, roughness: 0.2 });
        const playerMesh = new THREE.Mesh(geometry, playerMat);
        playerMesh.castShadow = true;
        scene.add(playerMesh);

        // --- Логика смены форм ---

        function getGeometryData(lvl) {
            // Циклическая смена форм
            const type = (lvl - 1) % 6;
            
            switch(type) {
                case 0: return { 
                    geo: new THREE.BoxGeometry(3, 3, 3), 
                    name: "Куб" 
                };
                case 1: return { 
                    geo: new THREE.TetrahedronGeometry(3), 
                    name: "Пирамида" 
                };
                case 2: return { 
                    geo: new THREE.OctahedronGeometry(2.5), 
                    name: "Октаэдр" 
                };
                case 3: return { 
                    geo: new THREE.ConeGeometry(1.5, 4, 16), 
                    name: "Конус" 
                };
                case 4: return { 
                    geo: new THREE.TorusGeometry(1.8, 0.6, 16, 50), 
                    name: "Тор (Пончик)" 
                };
                case 5: return { 
                    geo: new THREE.TorusKnotGeometry(1.2, 0.4, 100, 16), 
                    name: "Узел (Сложно!)" 
                };
                default: return { geo: new THREE.BoxGeometry(3,3,3), name: "Куб" };
            }
        }

        function startLevel() {
            isTransitioning = false;
            document.getElementById('win-msg').style.opacity = 0;
            document.getElementById('level-text').innerText = "УРОВЕНЬ: " + level;

            // Удаляем старую геометрию из памяти
            if (playerMesh.geometry) playerMesh.geometry.dispose();
            if (targetMesh.geometry) targetMesh.geometry.dispose();

            // Получаем новую
            const data = getGeometryData(level);
            playerMesh.geometry = data.geo;
            targetMesh.geometry = data.geo;
            document.getElementById('shape-name').innerText = data.name;

            // Сброс игрока
            playerMesh.rotation.set(0, 0, 0);
            playerMesh.material.color.setHex(0xffaa00);

            // Новый случайный поворот цели
            targetMesh.rotation.set(
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2
            );
        }

        function handleWin() {
            if (isTransitioning) return;
            isTransitioning = true;

            // Авто-доводка до идеала
            playerMesh.quaternion.copy(targetMesh.quaternion); 
            playerMesh.material.color.setHex(0x00ff88); 

            document.getElementById('win-msg').style.opacity = 1;

            setTimeout(() => {
                level++;
                startLevel();
            }, 1500);
        }

        // Запуск
        startLevel();

        // --- Управление (Мышь/Тач) ---
        document.addEventListener('mousedown', onDown);
        document.addEventListener('touchstart', (e) => onDown(e.touches[0]));
        
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('touchend', () => isDragging = false);
        
        document.addEventListener('mousemove', onMove);
        document.addEventListener('touchmove', (e) => onMove(e.touches[0]));

        function onDown(e) {
            isDragging = true;
            previousMouse = { x: e.clientX, y: e.clientY };
        }

        function onMove(e) {
            if (!isDragging || isTransitioning) return;

            const deltaX = e.clientX - previousMouse.x;
            const deltaY = e.clientY - previousMouse.y;

            playerMesh.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), deltaX * 0.01);
            playerMesh.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), deltaY * 0.01);

            previousMouse = { x: e.clientX, y: e.clientY };
        }

        // --- Анимация ---
        function animate() {
            requestAnimationFrame(animate);

            // Легкое покачивание
            const float = Math.sin(Date.now() * 0.002) * 0.1;
            playerMesh.position.y = float;
            targetMesh.position.y = float;

            if (!isTransitioning) {
                const angleDiff = playerMesh.quaternion.angleTo(targetMesh.quaternion);
                if (angleDiff < WIN_TOLERANCE) {
                    handleWin();
                }
            }
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>