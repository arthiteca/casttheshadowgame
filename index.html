<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Puzzle - Легкий режим</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Segoe UI', sans-serif; }
        
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: white;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; }
        #level-text { font-size: 1.2rem; color: #00ff88; font-weight: bold; margin-top: 5px; }
        
        #win-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff88;
            font-size: 4rem;
            font-weight: 800;
            text-shadow: 0 0 20px #00ff88;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-align: center;
        }
        #hint {
            position: absolute;
            bottom: 20px; width: 100%;
            text-align: center;
            color: #aaa;
            pointer-events: none;
            font-size: 0.9rem;
        }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="ui">
        <h1>SHADOW CAST</h1>
        <div id="level-text">УРОВЕНЬ: 1</div>
    </div>
    
    <div id="win-msg">ОТЛИЧНО!</div>
    <div id="hint">Крути куб, чтобы совпасть с зеленой целью. (Допускается погрешность)</div>

    <script type="module">
        import * as THREE from 'three';

        // --- Настройки игры ---
        let level = 1;
        
        // !!! ЗДЕСЬ МЕНЯЕМ СЛОЖНОСТЬ !!!
        // 0.2 = Сложно
        // 0.5 = Легко (большая погрешность)
        const WIN_TOLERANCE = 0.5; 

        let isDragging = false;
        let isTransitioning = false;
        let previousMouse = { x: 0, y: 0 };

        // --- Сцена ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Свет ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xffffff, 150);
        spotLight.position.set(5, 10, 10);
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 2048;
        spotLight.shadow.mapSize.height = 2048;
        scene.add(spotLight);

        // --- Объекты ---
        
        // Стена
        const wallGeo = new THREE.PlaneGeometry(50, 50);
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 });
        const wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.z = -8;
        wall.receiveShadow = true;
        scene.add(wall);

        const cubeGeometry = new THREE.BoxGeometry(3, 3, 3);

        // Цель (Призрак)
        const targetMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ff88, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.3 
        });
        const targetMesh = new THREE.Mesh(cubeGeometry, targetMat);
        scene.add(targetMesh);

        // Игрок
        const playerMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, roughness: 0.2 });
        const playerMesh = new THREE.Mesh(cubeGeometry, playerMat);
        playerMesh.castShadow = true;
        scene.add(playerMesh);

        // --- Логика ---

        function startLevel() {
            playerMesh.rotation.set(0, 0, 0);
            playerMesh.material.color.setHex(0xffaa00);

            // Новый случайный поворот цели
            targetMesh.rotation.set(
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2
            );

            document.getElementById('level-text').innerText = "УРОВЕНЬ: " + level;
            document.getElementById('win-msg').style.opacity = 0;
            isTransitioning = false;
        }

        function handleWin() {
            isTransitioning = true;
            
            // Визуальный эффект "примагничивания"
            // Раз мы разрешили погрешность, красиво будет, если куб сам довернется идеально
            playerMesh.quaternion.copy(targetMesh.quaternion); 
            playerMesh.material.color.setHex(0x00ff88); // Зеленый цвет

            document.getElementById('win-msg').style.opacity = 1;

            setTimeout(() => {
                level++;
                startLevel();
            }, 1500);
        }

        startLevel();

        // --- Управление ---

        document.addEventListener('mousedown', onDown);
        document.addEventListener('touchstart', (e) => onDown(e.touches[0]));
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('touchend', () => isDragging = false);
        document.addEventListener('mousemove', onMove);
        document.addEventListener('touchmove', (e) => onMove(e.touches[0]));

        function onDown(e) {
            isDragging = true;
            previousMouse = { x: e.clientX, y: e.clientY };
        }

        function onMove(e) {
            if (!isDragging || isTransitioning) return;

            const deltaX = e.clientX - previousMouse.x;
            const deltaY = e.clientY - previousMouse.y;

            playerMesh.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), deltaX * 0.01);
            playerMesh.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), deltaY * 0.01);

            previousMouse = { x: e.clientX, y: e.clientY };
        }

        // --- Анимация ---

        function animate() {
            requestAnimationFrame(animate);

            const float = Math.sin(Date.now() * 0.002) * 0.1;
            playerMesh.position.y = float;
            targetMesh.position.y = float;

            if (!isTransitioning) {
                // Проверка разницы углов
                const angleDiff = playerMesh.quaternion.angleTo(targetMesh.quaternion);
                
                // Если разница меньше нашего допуска (0.5), засчитываем победу
                if (angleDiff < WIN_TOLERANCE) {
                    handleWin();
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>