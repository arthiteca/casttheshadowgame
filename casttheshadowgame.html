<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Puzzle - Infinite Levels</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Segoe UI', sans-serif; }
        
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: white;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; }
        #level-text { font-size: 1.2rem; color: #00ff88; font-weight: bold; margin-top: 5px; }
        
        #win-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff88;
            font-size: 4rem;
            font-weight: 800;
            text-shadow: 0 0 20px #00ff88;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-align: center;
        }
        #hint {
            position: absolute;
            bottom: 20px; width: 100%;
            text-align: center;
            color: #aaa;
            pointer-events: none;
            font-size: 0.9rem;
        }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="ui">
        <h1>SHADOW CAST</h1>
        <div id="level-text">LEVEL: 1</div>
    </div>
    
    <div id="win-msg">MATCH!</div>
    <div id="hint">Drag to rotate. Align with the Green Ghost.</div>

    <script type="module">
        import * as THREE from 'three';

        // --- Game Variables ---
        let level = 1;
        let isDragging = false;
        let isTransitioning = false;
        let previousMouse = { x: 0, y: 0 };

        // --- Setup Scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.fog = new THREE.Fog(0x222222, 10, 40);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xffffff, 150);
        spotLight.position.set(5, 10, 10);
        spotLight.angle = Math.PI / 6;
        spotLight.penumbra = 0.3;
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 2048;
        spotLight.shadow.mapSize.height = 2048;
        scene.add(spotLight);

        // --- Objects ---
        
        // 1. Back Wall
        const wallGeo = new THREE.PlaneGeometry(50, 50);
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 });
        const wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.z = -8;
        wall.receiveShadow = true;
        scene.add(wall);

        // 2. Shared Geometry
        const cubeGeometry = new THREE.BoxGeometry(3, 3, 3);

        // 3. Target (The Ghost)
        const targetMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ff88, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.4 
        });
        const targetMesh = new THREE.Mesh(cubeGeometry, targetMat);
        scene.add(targetMesh);

        // 4. Player (The Solid Object)
        const playerMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, roughness: 0.2 });
        const playerMesh = new THREE.Mesh(cubeGeometry, playerMat);
        playerMesh.castShadow = true;
        scene.add(playerMesh);

        // --- Logic Functions ---

        function startLevel() {
            // Reset player rotation
            playerMesh.rotation.set(0, 0, 0);
            playerMesh.material.color.setHex(0xffaa00); // Orange

            // Set new random rotation for target
            targetMesh.rotation.set(
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2
            );

            // Update UI
            document.getElementById('level-text').innerText = "LEVEL: " + level;
            document.getElementById('win-msg').style.opacity = 0;
            isTransitioning = false;
        }

        function handleWin() {
            isTransitioning = true;
            
            // Visual Success Feedback
            playerMesh.material.color.setHex(0x00ff88); // Turn Green
            playerMesh.quaternion.copy(targetMesh.quaternion); // Snap perfectly
            
            // Show Text
            document.getElementById('win-msg').style.opacity = 1;

            // Wait and go to next level
            setTimeout(() => {
                level++;
                startLevel();
            }, 1500);
        }

        // Initialize First Level
        startLevel();

        // --- Input Handling ---

        document.addEventListener('mousedown', onDown);
        document.addEventListener('touchstart', (e) => onDown(e.touches[0]));
        
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('touchend', () => isDragging = false);

        document.addEventListener('mousemove', onMove);
        document.addEventListener('touchmove', (e) => onMove(e.touches[0]));

        function onDown(e) {
            isDragging = true;
            previousMouse = { x: e.clientX, y: e.clientY };
        }

        function onMove(e) {
            if (!isDragging || isTransitioning) return;

            const deltaX = e.clientX - previousMouse.x;
            const deltaY = e.clientY - previousMouse.y;

            // Rotate Object
            playerMesh.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), deltaX * 0.01);
            playerMesh.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), deltaY * 0.01);

            previousMouse = { x: e.clientX, y: e.clientY };
        }

        // --- Animation Loop ---

        function animate() {
            requestAnimationFrame(animate);

            // Slight float animation
            const float = Math.sin(Date.now() * 0.002) * 0.1;
            playerMesh.position.y = float;
            targetMesh.position.y = float;

            // Check Win Condition
            if (!isTransitioning) {
                const angleDiff = playerMesh.quaternion.angleTo(targetMesh.quaternion);
                // Threshold for winning (0.25 radians is roughly 15 degrees)
                if (angleDiff < 0.25) {
                    handleWin();
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>